/*//////////////////////////////////////////////////////////////////
////     The SKIRT project -- advanced radiative transfer       ////
////       © Astronomical Observatory, Ghent University         ////
///////////////////////////////////////////////////////////////// */

#ifndef ELECTRONMIX_HPP
#define ELECTRONMIX_HPP

#include "MaterialMix.hpp"
#include "ElectronExtinctionMixInterface.hpp"
#include "ScatteringMixInterface.hpp"

////////////////////////////////////////////////////////////////////

/** The ElectronMix class describes the material properties for a population of electrons,
    including support for polarization by scattering.

    Electrons do not absorb photons, and Thomson scattering of photons by electrons is
    wavelength-independent. The scattering cross section is given by the well-known Thomson cross
    section (a constant) and the Mueller matrix elements (and hence the phase function) can be
    expressed analytically as a function of just the scattering angle; see Bohren & Huffman (1998)
    or Wolf 2003 (Computer Physics Communications, 150, 99–115). */
class ElectronMix : public MaterialMix, public ElectronExtinctionMixInterface, public ScatteringMixInterface
{
    ITEM_CONCRETE(ElectronMix, MaterialMix, "a population of electrons")
    ITEM_END()

    //============= Implementing ElectronExtinctionMixInterface =============

public:
    /** This function returns the absorption cross section per electron
        \f$\varsigma^{\text{abs}}_{\lambda}\f$, which is trivially zero for all wavelengths
        \f$\lambda\f$. */
    double sigmaabs(double lambda) const override;

    /** This function returns the scattering cross section per electron
        \f$\varsigma^{\text{sca}}_{\lambda}\f$ which is constant and equal to the Thomson cross
        section for all wavelengths \f$\lambda\f$. */
    double sigmasca(double lambda) const override;

    /** This function returns the total extinction cross section per electron
        \f$\varsigma^{\text{ext}}_{\lambda} = \varsigma^{\text{abs}}_{\lambda} +
        \varsigma^{\text{sca}}_{\lambda}\f$ which is constant and equal to the Thomson cross
        section for all wavelengths \f$\lambda\f$.. */
    double sigmaext(double lambda) const override;

    /** This function returns the scattering albedo \f$\varpi_\lambda =
        \varsigma_{\lambda}^{\text{sca}} / \varsigma_{\lambda}^{\text{ext}} =
        \kappa_{\lambda}^{\text{sca}} / \kappa_{\lambda}^{\text{ext}}\f$ for the electron
        population, which is trivially equal to one for all wavelengths \f$\lambda\f$. */
    double albedo(double lambda) const override;

    //============= Implementing ScatteringMixInterface =============

public:
    /** This function returns true because the electron mix supports polarization by scattering. */
    bool hasScatteringPolarization() const override;

    /** This function generates a new direction \f${\bf{k}}_{\text{new}}\f$ in case the specified
        photon packet scatters, and calculates the new polarization state of the scattered photon
        packet. The function passes the new direction to the caller as its return value, and stores
        the new polarization state in the provided Stokes vector. It is permitted for the provided
        Stokes vector to actually reside in the specified photon packet.

        The function generates a new direction \f${\bf{k}}_{\text{new}}\f$ after a scattering
        event, given that the original direction before the scattering event is \f${\bf{k}}\f$ and
        taking into account the polarization state of the photon. First, the polarization degree
        and angle are computed from the Stokes parameters. Then, scattering angles \f$\theta\f$ and
        \f$\phi\f$ are sampled from the phase function, and the Stokes vector is rotated into the
        scattering plane and transformed by applying the Mueller matrix. Finally, the new direction
        is computed from the previously sampled \f$\theta\f$ and \f$\phi\f$ angles. */
    Direction scatteringDirectionAndPolarization(StokesVector* out, const PhotonPacket* pp) const override;

    /** This function calculates the polarization state appropriate for a peel off photon packet
        generated by a scattering event for the specified photon packet, and stores the result in
        the provided Stokes vector.

        The function rotates the Stokes vector from the reference direction in the previous
        scattering plane into the peel-off scattering plane, applies the Mueller matrix on the
        Stokes vector, and further rotates the Stokes vector from the reference direction in the
        peel-off scattering plane to the x-axis of the instrument to which the peel-off photon
        packet is headed. */
    void scatteringPeelOffPolarization(StokesVector* out, const PhotonPacket* pp, Direction bfknew,
                                       Direction bfkx, Direction bfky) override;

    /** This function returns the value of the scattering phase function in case the specified
        photon packet is scattered to the specified new direction, where the phase function is
        normalized as \f[\int\Phi_\lambda(\Omega)\,\mathrm{d}\Omega=4\pi.\f]

        The function returns the phase function for polarized radiation given by
        \f[\Phi_\lambda(\Omega) = N \left( S_{11,\lambda}(\theta) + P_\text{L}
        S_{12,\lambda}(\theta) \cos 2(\varphi-\gamma) \right)\f] where \f$\lambda\f$ is the
        wavelength of the photon packet, \f$\theta\f$ is the angle between the photon packet's
        propagation direction and the new scattering direction; \f$\phi\f$ is the angle between the
        previous and current scattering plane of the photon packet; \f$\gamma\f$ is the
        polarization angle of the photon packet, \f$P_\text{L}\f$ is the linear polarization degree
        of the photon packet; and \f$N\f$ is a normalization factor to ensure that the integral
        over the unit sphere is equal to \f$4\pi\f$. */
    double phaseFunctionValue(const PhotonPacket* pp, Direction bfknew) const override;
};

////////////////////////////////////////////////////////////////////

#endif
